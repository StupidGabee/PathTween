-- [[ Version 0.003 ]] --

local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")

local EasyPath = {}
EasyPath.__index = EasyPath

function EasyPath.new(character)
	local self = setmetatable({}, EasyPath)

	self.Character = character
	self.Root = character:WaitForChild("HumanoidRootPart")
	self.Humanoid = character:WaitForChild("Humanoid")

	self.Waypoints = {}
	self.Speed = 16
	self.Running = false
	self.Index = 1

	self.UseGradient = false
	self.GradientColors = {
		Color3.fromRGB(255, 0, 100),
		Color3.fromRGB(0, 200, 255),
		Color3.fromRGB(100, 255, 0)
	}
	
	self.Color = Color3.fromRGB(0,255,255)
	self.Width = 0.3
	
	self.SmoothDestroyDuration = 1.5
	self.AutoDestroy = true

	self.Visuals = {}
	self.Folder = Instance.new("Folder")
	self.Folder.Name = "EasyPathVisuals"
	self.Folder.Parent = workspace

	self._hb = nil

	return self
end

function EasyPath:SetSpeed(v)
	self.Speed = v
end

function EasyPath:SetVisuals(color, width)
	if color then self.Color = color end
	if width then self.Width = width end
	self:RefreshVisuals()
end

function EasyPath:SetGradient(enabled, colors)
	self.UseGradient = enabled
	if colors then
		self.GradientColors = colors
	end
	self:RefreshVisuals()
end

function EasyPath:_createGradientSequence()
	local keypoints = {}
	local numColors = #self.GradientColors
	
	for i, color in ipairs(self.GradientColors) do
		local time = (i - 1) / (numColors - 1)
		table.insert(keypoints, ColorSequenceKeypoint.new(time, color))
	end
	
	return ColorSequence.new(keypoints)
end

function EasyPath:AddPoint(cf)
	table.insert(self.Waypoints, cf)
	self:RefreshVisuals()
end

function EasyPath:ClearPoints()
	self.Waypoints = {}
	self.Index = 1
	self:ClearVisuals()
end

function EasyPath:ClearVisuals()
	for _,v in ipairs(self.Visuals) do
		if v.p then
			v.p:Destroy()
		end
	end
	self.Visuals = {}
	self._firstNode = nil
end

function EasyPath:_newNode(cf)
	local p = Instance.new("Part")
	p.Anchored = true
	p.CanCollide = false
	p.Transparency = 1
	p.Size = Vector3.one
	p.CFrame = cf
	p.Parent = self.Folder

	local a = Instance.new("Attachment", p)

	return p, a
end

function EasyPath:_newBeam(a0, a1, segmentIndex, totalSegments)
	local b = Instance.new("Beam")
	b.Attachment0 = a0
	b.Attachment1 = a1
	b.FaceCamera = true
	b.Width0 = self.Width
	b.Width1 = self.Width
	
	if self.UseGradient then
		b.Color = self:_createGradientSequence()
	else
		b.Color = ColorSequence.new(self.Color)
	end
	
	b.Transparency = NumberSequence.new(0)
	b.LightEmission = 1
	b.LightInfluence = 0
	
	b.Parent = self.Folder
	return b
end

function EasyPath:RefreshVisuals()
	self:ClearVisuals()

	if #self.Waypoints == 0 then
		return
	end

	local nodes = {}

	local p0, a0 = self:_newNode(self.Root.CFrame)
	table.insert(nodes, {p=p0, a=a0})

	for i, cf in ipairs(self.Waypoints) do
		local p, a = self:_newNode(cf)
		table.insert(nodes, {p=p, a=a})
	end

	local totalSegments = #nodes - 1
	
	for i = 1, totalSegments do
		local beam = self:_newBeam(nodes[i].a, nodes[i+1].a, i, totalSegments)
		table.insert(self.Visuals, {
			p = nodes[i].p,
			next = nodes[i+1].p,
			beam = beam
		})
	end

	self._firstNode = nodes[1].p
end

function EasyPath:Run()
	if self.Running then return end
	if #self.Waypoints == 0 then return end

	self.Running = true
	self.Index = 1

	self.Root.Anchored = true
	self.Humanoid.PlatformStand = true

	if self._hb then
		self._hb:Disconnect()
	end

	self._hb = RunService.Heartbeat:Connect(function()
		if self._firstNode then
			self._firstNode.CFrame = self.Root.CFrame
		end
	end)

	task.spawn(function()
		while self.Running and self.Index <= #self.Waypoints do
			local target = self.Waypoints[self.Index]

			while self.Running do
				local pos = self.Root.Position
				local tpos = target.Position
				local delta = tpos - pos
				local dist = delta.Magnitude

				if dist < 0.05 then
					self.Root.CFrame = target
					break
				end

				local dt = RunService.Heartbeat:Wait()
				local step = self.Speed * dt

				if step >= dist then
					self.Root.CFrame = target
				else
					local dir = delta / dist
					local newPos = pos + dir * step
					self.Root.CFrame = CFrame.new(newPos, newPos + self.Root.CFrame.LookVector)
				end
			end

			self.Index += 1
		end

		self:Stop()
		
		if self.AutoDestroy then
			self:SmoothDestroy()
		end
	end)
end

function EasyPath:Stop()
	self.Running = false

	if self._hb then
		self._hb:Disconnect()
		self._hb = nil
	end

	if self.Root then
		self.Root.Anchored = false
	end

	if self.Humanoid then
		self.Humanoid.PlatformStand = false
	end
end

function EasyPath:SmoothDestroy()
	local duration = self.SmoothDestroyDuration
	
	if self._hb then
		self._hb:Disconnect()
		self._hb = nil
	end
	
	local tweenInfo = TweenInfo.new(
		duration,
		Enum.EasingStyle.Quad,
		Enum.EasingDirection.Out
	)
	
	for _, visual in ipairs(self.Visuals) do
		if visual.beam then
			local tween = TweenService:Create(
				visual.beam,
				tweenInfo,
				{
					Width0 = 0,
					Width1 = 0,
					Transparency = NumberSequence.new(1)
				}
			)
			tween:Play()
		end
	end
	
	task.wait(duration)
	
	self:Destroy()
end

function EasyPath:Destroy()
	self:Stop()
	self:ClearVisuals()
	if self.Folder then
		self.Folder:Destroy()
	end
end

return EasyPath
