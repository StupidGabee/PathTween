-- [[ Version 0.06 ]] --

local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")

local EasyPath = {}
EasyPath.__index = EasyPath

function EasyPath.new(character)
	local self = setmetatable({}, EasyPath)

	self.Character = character
	self.Root = character:WaitForChild("HumanoidRootPart")
	self.Humanoid = character:WaitForChild("Humanoid")

	self.Waypoints = {}
	self.Speed = 16
	self.Running = false
	self.Paused = false
	self.Index = 1

	self.UseGradient = false
	self.GradientColors = {
		Color3.fromRGB(255, 0, 100),
		Color3.fromRGB(0, 200, 255),
		Color3.fromRGB(100, 255, 0)
	}
	
	self.Color = Color3.fromRGB(0,255,255)
	self.Width = 0.3
	
	self.SmoothDestroyDuration = 1.5
	self.AutoDestroy = true
	self.PauseOnReach = false
	self.OnWaypointReached = nil

	self.Visuals = {}
	self.Folder = Instance.new("Folder")
	self.Folder.Name = "EasyPathVisuals"
	self.Folder.Parent = workspace

	self._hb = nil
	self._diedConnection = nil
	
	self._diedConnection = self.Humanoid.Died:Connect(function()
		self:Destroy()
	end)

	return self
end

function EasyPath:SetSpeed(v)
	self.Speed = v
end

function EasyPath:SetVisuals(color, width)
	if color then self.Color = color end
	if width then self.Width = width end
	self:RefreshVisuals()
end

function EasyPath:SetGradient(enabled, colors)
	self.UseGradient = enabled
	if colors then
		self.GradientColors = colors
	end
	self:RefreshVisuals()
end

function EasyPath:SetPauseOnReach(enabled, callback)
	self.PauseOnReach = enabled
	self.OnWaypointReached = callback
end

function EasyPath:Pause()
	self.Paused = true
end

function EasyPath:Resume()
	self.Paused = false
end

function EasyPath:_createGradientSequence()
	local keypoints = {}
	local numColors = #self.GradientColors
	
	for i, color in ipairs(self.GradientColors) do
		local time = (i - 1) / (numColors - 1)
		table.insert(keypoints, ColorSequenceKeypoint.new(time, color))
	end
	
	return ColorSequence.new(keypoints)
end

function EasyPath:AddPoint(cf)
	table.insert(self.Waypoints, cf)
	self:RefreshVisuals()
end

function EasyPath:ClearPoints()
	self.Waypoints = {}
	self.Index = 1
	self:ClearVisuals()
end

function EasyPath:ClearVisuals()
	for _,v in ipairs(self.Visuals) do
		if v.p then
			v.p:Destroy()
		end
	end
	self.Visuals = {}
	self._firstNode = nil
end

function EasyPath:_newNode(cf)
	local p = Instance.new("Part")
	p.Anchored = true
	p.CanCollide = false
	p.Transparency = 1
	p.Size = Vector3.one
	p.CFrame = cf
	p.Parent = self.Folder

	local a = Instance.new("Attachment", p)

	return p, a
end

function EasyPath:_newBeam(a0, a1, segmentIndex, totalSegments)
	local b = Instance.new("Beam")
	b.Attachment0 = a0
	b.Attachment1 = a1
	b.FaceCamera = true
	b.Width0 = self.Width
	b.Width1 = self.Width
	
	if self.UseGradient then
		b.Color = self:_createGradientSequence()
	else
		b.Color = ColorSequence.new(self.Color)
	end
	
	b.Transparency = NumberSequence.new(0)
	b.LightEmission = 1
	b.LightInfluence = 0
	
	b.Parent = self.Folder
	return b
end

function EasyPath:RefreshVisuals()
	self:ClearVisuals()

	if #self.Waypoints == 0 then
		return
	end

	local nodes = {}

	local p0, a0 = self:_newNode(self.Root.CFrame)
	table.insert(nodes, {p=p0, a=a0})

	for i, cf in ipairs(self.Waypoints) do
		local p, a = self:_newNode(cf)
		table.insert(nodes, {p=p, a=a})
	end

	local totalSegments = #nodes - 1
	
	for i = 1, totalSegments do
		local beam = self:_newBeam(nodes[i].a, nodes[i+1].a, i, totalSegments)
		table.insert(self.Visuals, {
			p = nodes[i].p,
			next = nodes[i+1].p,
			beam = beam,
			index = i
		})
	end

	self._firstNode = nodes[1].p
end

function EasyPath:Run()
	if self.Running then return end
	if #self.Waypoints == 0 then return end

	self.Running = true
	self.Paused = false
	self.Index = 1

	self.Root.Anchored = true
	self.Humanoid.PlatformStand = true

	if self._hb then
		self._hb:Disconnect()
	end

	self._hb = RunService.Heartbeat:Connect(function()
		if self._firstNode and self.Index == 1 then
			self._firstNode.CFrame = self.Root.CFrame
		end
	end)

	task.spawn(function()
		while self.Running and self.Index <= #self.Waypoints do
			local target = self.Waypoints[self.Index]

			while self.Running do
				while self.Paused and self.Running do
					task.wait()
				end
				
				if not self.Running then break end
				
				local pos = self.Root.Position
				local tpos = target.Position
				local delta = tpos - pos
				local dist = delta.Magnitude

				if dist < 0.05 then
					self.Root.CFrame = target
					break
				end

				local dt = RunService.Heartbeat:Wait()
				local step = self.Speed * dt

				if step >= dist then
					self.Root.CFrame = target
				else
					local dir = delta / dist
					local newPos = pos + dir * step
					self.Root.CFrame = CFrame.new(newPos, newPos + self.Root.CFrame.LookVector)
				end
			end

			for _, visual in ipairs(self.Visuals) do
				if visual.index == self.Index then
					if visual.beam then
						visual.beam:Destroy()
					end
					if visual.p then
						visual.p:Destroy()
					end
					break
				end
			end

			if self.PauseOnReach then
				self.Paused = true
				if self.OnWaypointReached then
					task.spawn(self.OnWaypointReached, self.Index, self)
				end
			end

			self.Index += 1
		end

		self:Stop()
		
		if self.AutoDestroy then
			self:SmoothDestroy()
		end
	end)
end

function EasyPath:Stop()
	self.Running = false
	self.Paused = false

	if self._hb then
		self._hb:Disconnect()
		self._hb = nil
	end

	if self.Root then
		self.Root.Anchored = false
	end

	if self.Humanoid then
		self.Humanoid.PlatformStand = false
	end
end

function EasyPath:SmoothDestroy()
	local duration = self.SmoothDestroyDuration
	
	if self._hb then
		self._hb:Disconnect()
		self._hb = nil
	end
	
	self._firstNode = nil
	
	local tweenInfo = TweenInfo.new(
		duration,
		Enum.EasingStyle.Sine,
		Enum.EasingDirection.InOut
	)
	
	local remainingVisuals = {}
	for _, visual in ipairs(self.Visuals) do
		if visual.beam and visual.beam.Parent then
			table.insert(remainingVisuals, visual)
		end
	end
	
	local step = duration / math.max(#remainingVisuals, 1)
	
	for i, visual in ipairs(remainingVisuals) do
		task.spawn(function()
			task.wait((i - 1) * step * 0.5)
			if visual.beam and visual.beam.Parent then
				local tween = TweenService:Create(visual.beam, tweenInfo, {Width0 = 0, Width1 = 0})
				tween:Play()
			end
		end)
	end
	
	task.wait(duration)
	
	self:Destroy()
end

function EasyPath:Destroy()
	self:Stop()
	
	if self._diedConnection then
		self._diedConnection:Disconnect()
		self._diedConnection = nil
	end
	
	self:ClearVisuals()
	if self.Folder then
		self.Folder:Destroy()
	end
end

return EasyPath
