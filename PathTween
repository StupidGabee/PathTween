local RunService = game:GetService("RunService")

local EasyPath = {}
EasyPath.__index = EasyPath

function EasyPath.new(character)
	local self = setmetatable({}, EasyPath)

	self.Character = character
	self.Root = character:WaitForChild("HumanoidRootPart")
	self.Humanoid = character:WaitForChild("Humanoid")

	self.Waypoints = {}
	self.Speed = 16
	self.Running = false
	self.Index = 1

	self.Color = Color3.fromRGB(0,255,255)
	self.Width = 0.3

	self.Visuals = {}
	self.Folder = Instance.new("Folder")
	self.Folder.Name = "EasyPathVisuals"
	self.Folder.Parent = workspace

	self._hb = nil

	return self
end

function EasyPath:SetSpeed(v)
	self.Speed = v
end

function EasyPath:SetVisuals(color,width)
	if color then self.Color = color end
	if width then self.Width = width end
	self:RefreshVisuals()
end

function EasyPath:AddPoint(cf)
	table.insert(self.Waypoints, cf)
	self:RefreshVisuals()
end

function EasyPath:ClearPoints()
	self.Waypoints = {}
	self.Index = 1
	self:ClearVisuals()
end

function EasyPath:ClearVisuals()
	for _,v in ipairs(self.Visuals) do
		v.p:Destroy()
	end
	self.Visuals = {}
end

function EasyPath:_newNode(cf)
	local p = Instance.new("Part")
	p.Anchored = true
	p.CanCollide = false
	p.Transparency = 1
	p.Size = Vector3.one
	p.CFrame = cf
	p.Parent = self.Folder

	local a = Instance.new("Attachment",p)

	return p,a
end

function EasyPath:_newBeam(a0,a1)
	local b = Instance.new("Beam")
	b.Attachment0 = a0
	b.Attachment1 = a1
	b.FaceCamera = true
	b.Width0 = self.Width
	b.Width1 = self.Width
	b.Color = ColorSequence.new(self.Color)
	b.Parent = self.Folder
	return b
end

function EasyPath:RefreshVisuals()
	self:ClearVisuals()

	if #self.Waypoints == 0 then
		return
	end

	local nodes = {}

	local p0,a0 = self:_newNode(self.Root.CFrame)
	table.insert(nodes,{p=p0,a=a0})

	for i,cf in ipairs(self.Waypoints) do
		local p,a = self:_newNode(cf)
		table.insert(nodes,{p=p,a=a})
	end

	for i=1,#nodes-1 do
		local beam = self:_newBeam(nodes[i].a,nodes[i+1].a)
		table.insert(self.Visuals,{
			p = nodes[i].p,
			next = nodes[i+1].p,
			beam = beam
		})
	end

	self._firstNode = nodes[1].p
end

function EasyPath:Run()
	if self.Running then return end
	if #self.Waypoints == 0 then return end

	self.Running = true
	self.Index = 1

	self.Root.Anchored = true
	self.Humanoid.PlatformStand = true

	if self._hb then
		self._hb:Disconnect()
	end

	self._hb = RunService.Heartbeat:Connect(function()
		if self._firstNode then
			self._firstNode.CFrame = self.Root.CFrame
		end
	end)

	task.spawn(function()
		while self.Running and self.Index <= #self.Waypoints do
			local target = self.Waypoints[self.Index]

			while self.Running do
				local pos = self.Root.Position
				local tpos = target.Position
				local delta = tpos - pos
				local dist = delta.Magnitude

				if dist < 0.05 then
					self.Root.CFrame = target
					break
				end

				local dt = RunService.Heartbeat:Wait()
				local step = self.Speed * dt

				if step >= dist then
					self.Root.CFrame = target
				else
					local dir = delta / dist
					local newPos = pos + dir * step
					self.Root.CFrame = CFrame.new(newPos, newPos + self.Root.CFrame.LookVector)
				end
			end

			self.Index += 1
		end

		self:Stop()
	end)
end

function EasyPath:Stop()
	self.Running = false

	if self._hb then
		self._hb:Disconnect()
		self._hb = nil
	end

	if self.Root then
		self.Root.Anchored = false
	end

	if self.Humanoid then
		self.Humanoid.PlatformStand = false
	end
end

function EasyPath:Destroy()
	self:Stop()
	self:ClearVisuals()
	if self.Folder then
		self.Folder:Destroy()
	end
end

return EasyPath
